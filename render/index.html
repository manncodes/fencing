<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fencing Simulator</title>

    <!-- Three.js and GSAP for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        body {
            margin: 0;
            background: #0f172a;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #stats {
            position: fixed;
            top: 0;
            width: 100%;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .fencer-stats {
            padding: 10px;
            border-radius: 5px;
            width: 200px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #fencer1-stats {
            background: rgba(0, 100, 255, 0.3);
        }

        #fencer2-stats {
            background: rgba(255, 0, 0, 0.3);
        }

        #current-action {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            min-width: 200px;
            transition: background-color 0.3s;
        }

        #info {
            position: fixed;
            bottom: 0;
            width: 100%;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .info-panel {
            padding: 10px;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
            width: 45%;
        }

        #history {
            max-height: 100px;
            overflow-y: auto;
            padding-right: 10px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.3);
        }

        #history::-webkit-scrollbar {
            width: 6px;
        }

        #history::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        #history::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 1000;
        }

        #status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: red;
            transition: background-color 0.3s;
        }

        #status-dot.connected {
            background: #4CAF50;
        }

        #reconnect-button {
            display: none;
            margin-left: 10px;
            padding: 2px 8px;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s;
        }

        #reconnect-button:hover {
            background: #45a049;
        }

        .success-indicator {
            position: absolute;
            padding: 5px 10px;
            border-radius: 4px;
            color: white;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .success {
            background: rgba(76, 175, 80, 0.8);
        }

        .failure {
            background: rgba(244, 67, 54, 0.8);
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <!-- Stats Bar -->
    <div id="stats">
        <div id="fencer1-stats" class="fencer-stats">
            <div class="name">ðŸ¤º Alice</div>
            <div class="score">Score: <span id="score1">0</span></div>
            <div class="blade">Blade: SIXTE</div>
            <div class="skill">Skill: 70%</div>
        </div>

        <div id="current-action">
            Current Action: <span id="action">None</span>
        </div>

        <div id="fencer2-stats" class="fencer-stats">
            <div class="name">ðŸ¤º Bob</div>
            <div class="score">Score: <span id="score2">0</span></div>
            <div class="blade">Blade: QUARTE</div>
            <div class="skill">Skill: 60%</div>
        </div>
    </div>

    <!-- Connection Status -->
    <div class="connection-status">
        <span id="status-dot"></span>
        <span id="status-text">Disconnected</span>
    </div>

    <!-- Info Panels -->
    <div id="info">
        <div class="info-panel">
            <h3>Distance Information</h3>
            <div id="distance">Current: MEDIUM</div>
            <div id="range">Range: 1.5m - 2.0m</div>
        </div>

        <div class="info-panel">
            <h3>Action History</h3>
            <div id="history"></div>
        </div>
    </div>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f172a);
        scene.fog = new THREE.Fog(0x0f172a, 5, 15);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Ground and Piste
        const groundGeometry = new THREE.PlaneGeometry(20, 10);
        const groundMaterial = new THREE.MeshPhongMaterial({
            color: 0x1e293b,
            roughness: 1,
            metalness: 0
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1.1;
        ground.receiveShadow = true;
        scene.add(ground);

        // Blade positions
        // Update blade positions to account for side orientation
        const bladePositions = {
            SIXTE: {
                armRotationY: 0,
                armRotationZ: -Math.PI / 3,  // Raised slightly
                bladeRotationX: Math.PI / 6   // Angled slightly forward
            },
            QUARTE: {
                armRotationY: Math.PI / 6,
                armRotationZ: -Math.PI / 3,
                bladeRotationX: -Math.PI / 6  // Angled inside
            },
            SEPTIME: { armRotationY: 0, armRotationZ: -Math.PI / 3, bladeRotationX: Math.PI / 6 },
            OCTAVE: { armRotationY: 0, armRotationZ: -Math.PI / 4, bladeRotationX: Math.PI / 4 },
            PRIME: { armRotationY: 0, armRotationZ: -3 * Math.PI / 4, bladeRotationX: -Math.PI / 6 },
            SECONDE: { armRotationY: 0, armRotationZ: -Math.PI / 2, bladeRotationX: Math.PI / 6 },
            TIERCE: { armRotationY: 0, armRotationZ: -Math.PI / 4, bladeRotationX: Math.PI / 6 },
            QUINTE: { armRotationY: 0, armRotationZ: -Math.PI / 6, bladeRotationX: -Math.PI / 6 }
        };

        function createFencer(color, position, isLeftSide) {  // Add isLeftSide parameter
            const group = new THREE.Group();

            // Body and head code remains the same
            const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.8, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            group.add(body);

            const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 1.1;
            head.castShadow = true;
            group.add(head);

            // Updated arm group with forward-facing orientation
            const armGroup = new THREE.Group();

            // Upper arm - adjusted to point forward
            const upperArmGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
            const upperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            upperArm.position.y = -0.2;
            upperArm.rotation.x = Math.PI / 2;  // Point forward
            upperArm.rotation.z = -Math.PI / 6;
            armGroup.add(upperArm);

            // Forearm - adjusted to point forward
            const forearmGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.4, 8);
            const forearm = new THREE.Mesh(forearmGeometry, bodyMaterial);
            forearm.position.y = -0.6;
            forearm.position.z = 0.1;  // Move forward
            forearm.rotation.x = Math.PI / 2;  // Point forward
            forearm.rotation.z = -Math.PI / 4;
            armGroup.add(forearm);

            // Updated sword group with corrected orientation
            const swordGroup = new THREE.Group();

            // Handle - aligned for proper grip
            const handleGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.2, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({ color: 0x4a4a4a });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.rotation.x = Math.PI / 2; // Point forward
            swordGroup.add(handle);

            // Guard - perpendicular to blade like a real fencing sword
            const guardGeometry = new THREE.TorusGeometry(0.08, 0.01, 8, 16);
            const guardMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const guard = new THREE.Mesh(guardGeometry, guardMaterial);
            guard.position.y = 0.1;
            guard.rotation.x = Math.PI / 2; // Orient perpendicular to blade
            swordGroup.add(guard);

            // Blade - proper fencing angle
            const bladeGeometry = new THREE.CylinderGeometry(0.008, 0.002, 1.0, 8);
            const bladeMaterial = new THREE.MeshPhongMaterial({
                color: 0xcccccc,
                metalness: 0.9,
                roughness: 0.1
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = 0.6; // Position forward of guard
            blade.rotation.x = -Math.PI / 6; // Slight upward angle
            swordGroup.add(blade);

            // Position entire sword group
            swordGroup.position.set(
                isLeftSide ? 0.2 : -0.2, // Offset to appropriate side
                0.8, // Height
                0.3  // Forward position
            );

            // Rotate sword group for proper en garde
            swordGroup.rotation.set(
                Math.PI / 6, // Tilt up slightly
                isLeftSide ? -Math.PI / 6 : Math.PI / 6, // Angle in/out based on side
                isLeftSide ? -Math.PI / 3 : Math.PI / 3  // Rotate to side
            );

            armGroup.add(swordGroup);

            // Position arm group with proper side orientation
            armGroup.position.set(isLeftSide ? 0.3 : -0.3, 0.8, 0);
            group.add(armGroup);

            // Initial rotation to face opponent
            group.rotation.y = isLeftSide ? Math.PI : 0;

            group.userData = {
                armGroup: armGroup,
                swordGroup: swordGroup,
                blade: blade,
                initialPosition: position.clone(),
                isLeftSide: isLeftSide  // Store side information
            };

            group.position.copy(position);
            return group;
        }
        // Create fencers
        // Updated fencer creation with explicit side parameter
        const fencer1 = createFencer(0x4299e1, new THREE.Vector3(-2, 0, 0), true);   // Blue, left side
        const fencer2 = createFencer(0xf56565, new THREE.Vector3(2, 0, 0), false);  // Red, right side

        fencer1.rotation.y = -Math.PI / 2;
        fencer2.rotation.y = Math.PI / 2;
        scene.add(fencer1);
        scene.add(fencer2);

        // Position camera
        camera.position.set(0, 4, 8);
        camera.lookAt(0, 0, 0);

        // Animation functions 
        function animateToPosition(fencer, position, duration = 0.5) {
            const armGroup = fencer.userData.armGroup;
            const swordGroup = fencer.userData.swordGroup;
            const isLeftSide = fencer.position.x < 0;

            gsap.to(armGroup.rotation, {
                y: isLeftSide ? position.armRotationY : -position.armRotationY,
                z: position.armRotationZ,
                duration: duration,
                ease: "power2.inOut"
            });

            gsap.to(swordGroup.rotation, {
                x: isLeftSide ? position.bladeRotationX : -position.bladeRotationX,
                duration: duration,
                ease: "power2.inOut"
            });
        }

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Create piste (fencing strip)
        const pisteGeometry = new THREE.BoxGeometry(14, 0.1, 2);
        const pisteMaterial = new THREE.MeshPhongMaterial({
            color: 0x2a4858,
            roughness: 0.5,
            metalness: 0.5
        });
        const piste = new THREE.Mesh(pisteGeometry, pisteMaterial);
        piste.position.y = -1; // Move it below the fencers
        piste.receiveShadow = true;
        scene.add(piste);

        // Add center line
        const lineGeometry = new THREE.BoxGeometry(0.1, 0.11, 2);
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const centerLine = new THREE.Mesh(lineGeometry, lineMaterial);
        centerLine.position.y = -0.95;
        scene.add(centerLine);

        // Add warning lines
        const warningLineLeft = new THREE.Mesh(lineGeometry, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        warningLineLeft.position.set(-2, -0.95, 0);
        scene.add(warningLineLeft);

        const warningLineRight = new THREE.Mesh(lineGeometry, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        warningLineRight.position.set(2, -0.95, 0);
        scene.add(warningLineRight);

        // Position camera
        camera.position.set(0, 3, 8);
        camera.lookAt(0, 0, 0);

        // WebSocket setup
        let ws;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        function setupWebSocket() {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');

            ws = new WebSocket('ws://localhost:8765');

            ws.onopen = () => {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
                reconnectAttempts = 0;
            };

            function showReconnectButton() {
                const button = document.getElementById('reconnect-button') ||
                    createReconnectButton();
                button.style.display = 'inline-block';
            }

            function createReconnectButton() {
                const button = document.createElement('button');
                button.id = 'reconnect-button';
                button.textContent = 'Reconnect';
                button.onclick = () => {
                    button.style.display = 'none';
                    reconnectAttempts = 0;
                    setupWebSocket();
                };
                document.querySelector('.connection-status').appendChild(button);
                return button;
            }

            ws.onclose = () => {
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';

                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    setTimeout(setupWebSocket, 2000);
                } else {
                    statusText.textContent = 'Connection Failed';
                    showReconnectButton();
                }
            };


            ws.onmessage = function (event) {
                const data = JSON.parse(event.data);

                // Update UI
                document.getElementById('score1').textContent = data.fencer1.score;
                document.getElementById('score2').textContent = data.fencer2.score;

                if (data.current_action) {
                    const actionElement = document.getElementById('action');
                    actionElement.textContent = data.current_action;

                    // Flash effect for new action
                    const actionDisplay = document.getElementById('current-action');
                    actionDisplay.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                    setTimeout(() => {
                        actionDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                    }, 500);
                }

                if (data.distance) {
                    document.getElementById('distance').textContent = `Current: ${data.distance}`;
                    document.getElementById('range').textContent =
                        `Range: ${data.distance_info.range[0]}m - ${data.distance_info.range[1]}m`;

                    // Update fencer positions based on distance
                    updateFencerDistance(data.distance);
                }

                // Handle blade positions and animations
                if (data.fencer1.blade_position) {
                    animateToPosition(fencer1, bladePositions[data.fencer1.blade_position]);
                }
                if (data.fencer2.blade_position) {
                    animateToPosition(fencer2, bladePositions[data.fencer2.blade_position]);
                }

                // Handle action animations
                if (data.current_action && data.last_action_details) {
                    const attacker = data.last_action_details.fencer === data.fencer1.name ? fencer1 : fencer2;
                    const defender = data.last_action_details.fencer === data.fencer1.name ? fencer2 : fencer1;

                    animateAction(attacker, defender, data.current_action, data.last_action_details.success);
                }

                // Update history
                if (data.action_history && data.action_history.length > 0) {
                    const historyDiv = document.getElementById('history');
                    historyDiv.innerHTML = data.action_history.join('<br>');
                    historyDiv.scrollTop = historyDiv.scrollHeight;
                }
            };
        }

        function animateAction(attacker, defender, actionType, success) {
            const timeline = gsap.timeline();
            const isLeftSide = attacker.userData.isLeftSide;
            const attackDirection = isLeftSide ? 1 : -1;

            switch (actionType) {
                case "Direct Thrust":
                    timeline
                        .to(attacker.userData.armGroup.rotation, {
                            y: Math.PI / 2,  // Forward thrust
                            duration: 0.2
                        })
                        .to(attacker.position, {
                            x: attacker.position.x + (0.5 * attackDirection),  // Move forward
                            duration: 0.3,
                            ease: "power2.inOut"
                        })
                        .to(attacker.userData.swordGroup.rotation, {
                            x: isLeftSide ? Math.PI / 6 : -Math.PI / 6,  // Adjust blade angle
                            duration: 0.2
                        })
                        .to(attacker.position, {
                            x: attacker.userData.initialPosition.x,  // Return to start
                            duration: 0.3
                        });
                    break;

                case "Point in Line":
                    timeline
                        .to(attacker.userData.armGroup.rotation, {
                            z: -Math.PI / 2,  // Extend arm
                            duration: 0.2
                        })
                        .to(attacker.userData.armGroup.rotation, {
                            y: isLeftSide ? 0 : Math.PI,  // Point towards opponent
                            duration: 0.2
                        });
                    break;

                case "Disengage":
                    timeline
                        .to(attacker.userData.swordGroup.rotation, {
                            y: Math.PI / 4,  // Start blade movement
                            duration: 0.15
                        })
                        .to(attacker.userData.swordGroup.rotation, {
                            y: -Math.PI / 4,  // Complete disengage
                            duration: 0.15
                        })
                        .to(attacker.userData.armGroup.rotation, {
                            z: -Math.PI / 2,  // Extend arm
                            duration: 0.2
                        })
                        .to(attacker.position, {
                            x: attacker.position.x + (attackDirection * 0.5), // Move along x-axis
                            duration: 0.3,
                            ease: "power2.inOut"
                        })
                        .to(attacker.position, {
                            x: attacker.userData.initialPosition.x,
                            duration: 0.3
                        })
                        .to(attacker.userData.swordGroup.rotation, {
                            y: 0,
                            duration: 0.2
                        });
                    break;

                case "Cut Over":
                    timeline
                        .to(attacker.userData.swordGroup.rotation, {
                            x: Math.PI / 3,  // Lift blade
                            duration: 0.2
                        })
                        .to(attacker.userData.armGroup.rotation, {
                            z: -Math.PI / 2.5,  // Extend slightly
                            duration: 0.2
                        })
                        .to(attacker.userData.swordGroup.rotation, {
                            x: 0,  // Drop blade
                            duration: 0.2
                        })
                        .to(attacker.position, {
                            x: attacker.position.x + (attackDirection * 0.5), // Move along x-axis
                            duration: 0.3,
                            ease: "power2.inOut"
                        })
                        .to(attacker.position, {
                            x: attacker.userData.initialPosition.x,
                            duration: 0.3
                        });
                    break;
            }

            showActionResult(attacker, success);
        }

        function updateFencerDistance(distanceType) {
            const distanceMap = {
                'OUT_OF_DISTANCE': 6,
                'LONG': 4,
                'MEDIUM': 3,
                'LUNGE': 2,
                'SHORT': 1.5,
                'INFIGHTING': 1
            };

            const distance = distanceMap[distanceType] || 3;

            gsap.to(fencer1.position, {
                x: -distance / 2,
                duration: 0.5,
                ease: "power2.inOut"
            });

            gsap.to(fencer2.position, {
                x: distance / 2,
                duration: 0.5,
                ease: "power2.inOut"
            });
        }

        function showActionResult(fencer, success) {
            const indicator = document.createElement('div');
            indicator.className = `success-indicator ${success ? 'success' : 'failure'}`;
            indicator.textContent = success ? 'Hit!' : 'Miss';

            indicator.style.left = `${fencer.position.x > 0 ? '60%' : '40%'}`;
            indicator.style.top = '50%';

            document.body.appendChild(indicator);

            gsap.to(indicator, {
                opacity: 1,
                y: -50,
                duration: 0.3,
                onComplete: () => {
                    setTimeout(() => {
                        gsap.to(indicator, {
                            opacity: 0,
                            duration: 0.3,
                            onComplete: () => indicator.remove()
                        });
                    }, 1000);
                }
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Initialize
        setupWebSocket();
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>

    <script>
        // Test function to verify animations work for both fencers
        function testFencerAnimations() {
            console.log("Testing fencer animations...");

            // Test fencer1 (blue)
            console.log("Testing blue fencer...");
            const blueFencerTest = animateAction(fencer1, fencer2, "Direct Thrust", true);

            // Test fencer2 (red)
            console.log("Testing red fencer...");
            const redFencerTest = animateAction(fencer2, fencer1, "Direct Thrust", true);
        }

        // Add this to check if fencers are properly initialized
        console.log("Fencer 1:", fencer1);
        console.log("Fencer 2:", fencer2);

    </script>
    <button onclick="testFencerAnimations()"
        style="position: fixed; top: 10px; left: 50%; transform: translateX(-50%); z-index: 1000;">
        Test Animations
    </button>
</body>

</html>